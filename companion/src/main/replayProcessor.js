const fs = require('fs');

const axios = require('axios');
const parseReplay = require('fortnite-replay-parser');

const { log, stripPath } = require('./utils/logger');

const parserConfig = {
    parseLevel: 10,
    debug: true,
}

const autoGeneratedFiles = [
    'netfieldexports.txt',
    'netGuidToPathName.txt',
    'notReadingGroups.txt'
]

/**
 * Process replay files.
 * @param {string} filePath The file to process.
 * @param {BrowserWindow} mainWindow The Electron window to log messages to.
 * @param {object} config Config file content
 */
async function processFile(filePath, mainWindow, config) {
    const replayBuffer = fs.readFileSync(filePath);
    const parsedReplay = await parseReplay(replayBuffer, parserConfig);

    if (process.platform === 'darwin') {
        fs.writeFileSync('replayData.json', JSON.stringify(parsedReplay));
    }

    await parseReplayContent(parsedReplay, mainWindow, config);
    deleteReplayDataFiles(mainWindow);

    log(`Completed: ${stripPath(filePath)}`, mainWindow);
}

/**
 * Parse replay content to extract party killed and killed_by data,
 * and send condensed dataset to the backend API.
 *
 * @param {object} parsedReplay ReplayData JSON content
 * @param {BrowserWindow} mainWindow Main app window for sending UI updates
 * @param {object} config Config object
 */
async function parseReplayContent(parsedReplay, mainWindow, config) {
    const playerNamesMap = config.fortnite.guidToPlayerName;

    const playerElimRecords = parsedReplay.events.reduce((accumulator, event) => {
        if (event.group !== 'playerElim') {
            return accumulator;
        }

        if (event.eliminator in playerNamesMap) {
            const playerId = playerNamesMap[event.eliminator];
            addToAccumulator(accumulator.killed, playerId, event.eliminated);
        } else if (event.eliminated in playerNamesMap) {
            const playerId = playerNamesMap[event.eliminated];
            addToAccumulator(accumulator.killed_by, playerId, event.eliminator);
        }
        return accumulator;
      }, { killed: {}, killed_by: {} });

    const payload = {
        game_mode: parsedReplay.gameData.playlistInfo,
        killed: playerElimRecords.killed,
        killed_by: playerElimRecords.killed_by
    };

    log(`Replay Content: ${JSON.stringify(payload)}`, mainWindow);

    await sendToDiscordBot(payload, mainWindow);

    log(`Sent to Discord bot. Response: ${JSON.stringify(response)}`)
}

/**
 * Push player information to the object key list.
 * @param {object} obj
 * @param {str} key
 * @param {str} value
 */
function addToAccumulator(obj, key, value) {
    if (!Array.isArray(obj[key])) {
        obj[key] = [value];
    } else {
        obj[key].push(value);
    }
}

/**
 * Send game elimination data to the Fortnite Discord bot.
 *
 * @param {object} payload Data to send to the Discord bot
 * @param {BrowserWindow} mainWindow The Electron window to log messages to
 * @returns {Promise<object|null>} The response from the Discord bot or null if an error occurred
 */
async function sendToDiscordBot(payload, mainWindow) {
    try {
        const response = await axios.post(
            process.env.FORTNITE_DISCORD_BOT_GAME_URL,
            payload,
            {
                headers: {
                    'Content-Type': 'application/json',
                    'API-TOKEN': process.env.FORTNITE_DISCORD_BOT_API_TOKEN
                }
            }
        );
        return response.data;
    } catch (error) {
        let error_msg;

        if (error.response) {
            error_msg = `Error: Failed to call Discord bot. ${error.response.status}: ${error.response.data}`
        } else if (error.request) {
            error_msg = 'Error: Failed to call Discord bot as no response was received.'
        } else {
            error_msg = `Error: Failed to call Discord bot due to unexpected error. ${error.message}`
        }
        log(error_msg, mainWindow, 'error')

        throw error;
    }
};


/**
 * Delete replay data files created by the parser library.
 * @param {BrowserWindow} mainWindow The Electron window to log messages to
 */
function deleteReplayDataFiles(mainWindow) {
    for (const file of autoGeneratedFiles) {
        try {
            fs.unlinkSync(file);
        } catch (err) {
            log(`Error: Failed to delete ${file}. ${err}`, mainWindow, 'error');
        }
    }
}

module.exports = {
    processFile
};
